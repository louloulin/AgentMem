# AgentMem 部署模式对比指南

**版本**: v1.0  
**日期**: 2025-10-16

---

## 📊 快速对比表

| 维度 | 嵌入式模式 | Server 模式 |
|------|-----------|------------|
| **部署复杂度** | ⭐⭐⭐⭐⭐ 零配置 | ⭐⭐⭐☆☆ 需配置数据库 |
| **性能 (小规模)** | ⭐⭐⭐⭐⭐ 优秀 | ⭐⭐⭐⭐☆ 良好 |
| **性能 (大规模)** | ⭐⭐☆☆☆ 一般 | ⭐⭐⭐⭐⭐ 优秀 |
| **可扩展性** | ⭐⭐☆☆☆ 垂直扩展 | ⭐⭐⭐⭐⭐ 水平扩展 |
| **高可用** | ❌ 不支持 | ✅ 支持 |
| **运维成本** | ⭐⭐⭐⭐⭐ 极低 | ⭐⭐⭐☆☆ 中等 |
| **基础设施成本** | ⭐⭐⭐⭐⭐ 极低 | ⭐⭐☆☆☆ 较高 |
| **适用向量数** | < 100万 | 无限制 |
| **适用并发** | < 100 QPS | 无限制 |

---

## 🎯 决策树

```
开始
  │
  ├─ 向量数量 > 100万？
  │   ├─ 是 → Server 模式
  │   └─ 否 → 继续
  │
  ├─ 并发 > 100 QPS？
  │   ├─ 是 → Server 模式
  │   └─ 否 → 继续
  │
  ├─ 需要高可用？
  │   ├─ 是 → Server 模式
  │   └─ 否 → 继续
  │
  ├─ 需要分布式部署？
  │   ├─ 是 → Server 模式
  │   └─ 否 → 继续
  │
  ├─ 是边缘设备/桌面应用？
  │   ├─ 是 → 嵌入式模式
  │   └─ 否 → 继续
  │
  └─ 追求极简部署？
      ├─ 是 → 嵌入式模式
      └─ 否 → Server 模式
```

---

## 📋 详细对比

### 1. 技术架构

#### 嵌入式模式
```
应用程序
  ├─ LibSQL (结构化数据)
  └─ LanceDB (向量数据)
```

**特点**:
- ✅ 单进程，无网络开销
- ✅ 数据本地化
- ✅ 零配置
- ❌ 无法跨进程共享

#### Server 模式
```
应用程序
  │
  ├─ PostgreSQL (结构化数据)
  │   └─ pgvector (向量扩展)
  │
  └─ 向量服务 (可选)
      ├─ LanceDB
      ├─ Qdrant
      ├─ Pinecone
      ├─ Milvus
      └─ ...
```

**特点**:
- ✅ 多进程共享
- ✅ 网络访问
- ✅ 高可用
- ❌ 需要配置和维护

---

### 2. 性能对比

#### 小规模 (< 10万向量)

| 操作 | 嵌入式模式 | Server 模式 | 优势 |
|------|-----------|------------|------|
| **插入** | 31,456 ops/s | ~5,000 ops/s | 嵌入式 **6.3x** |
| **搜索** | 22.98 ms | ~10 ms | Server **2.3x** |
| **更新** | 1,291 ops/s | ~500 ops/s | 嵌入式 **2.6x** |
| **删除** | 3,815 ops/s | ~1,000 ops/s | 嵌入式 **3.8x** |

**结论**: 小规模下，嵌入式模式性能更优。

#### 大规模 (> 100万向量)

| 操作 | 嵌入式模式 | Server 模式 | 优势 |
|------|-----------|------------|------|
| **插入** | ~1,000 ops/s | ~5,000 ops/s | Server **5x** |
| **搜索** | ~100 ms | ~10 ms | Server **10x** |
| **更新** | ~100 ops/s | ~500 ops/s | Server **5x** |
| **删除** | ~500 ops/s | ~1,000 ops/s | Server **2x** |

**结论**: 大规模下，Server 模式性能更优。

---

### 3. 成本对比

#### 基础设施成本 (月度)

| 规模 | 嵌入式模式 | Server 模式 (自建) | Server 模式 (云服务) |
|------|-----------|------------------|-------------------|
| **小型** (< 10万) | $0 | $50-100 | $100-200 |
| **中型** (10万-100万) | $0 | $200-500 | $500-1000 |
| **大型** (> 100万) | N/A | $1000-5000 | $2000-10000 |

#### 运维成本 (人天/月)

| 任务 | 嵌入式模式 | Server 模式 |
|------|-----------|------------|
| **部署** | 0.1 | 2-5 |
| **监控** | 0.5 | 2-3 |
| **备份** | 0.2 | 1-2 |
| **升级** | 0.1 | 1-2 |
| **故障处理** | 0.5 | 2-5 |
| **总计** | **1.4 天/月** | **8-17 天/月** |

**结论**: 嵌入式模式运维成本极低。

---

### 4. 可靠性对比

| 指标 | 嵌入式模式 | Server 模式 |
|------|-----------|------------|
| **数据持久化** | ✅ 自动 | ✅ 自动 |
| **崩溃恢复** | ✅ 支持 | ✅ 支持 |
| **高可用** | ❌ 不支持 | ✅ 支持 (主从/集群) |
| **故障转移** | ❌ 不支持 | ✅ 支持 |
| **数据备份** | ✅ 简单 (文件复制) | ✅ 完善 (多种方案) |
| **预期可用性** | 99.0% | 99.9%+ |

---

### 5. 扩展性对比

#### 垂直扩展

| 资源 | 嵌入式模式 | Server 模式 |
|------|-----------|------------|
| **CPU** | ✅ 支持 | ✅ 支持 |
| **内存** | ✅ 支持 | ✅ 支持 |
| **磁盘** | ✅ 支持 | ✅ 支持 |

#### 水平扩展

| 特性 | 嵌入式模式 | Server 模式 |
|------|-----------|------------|
| **多实例** | ❌ 不支持 | ✅ 支持 |
| **负载均衡** | ❌ 不支持 | ✅ 支持 |
| **分布式存储** | ❌ 不支持 | ✅ 支持 |
| **读写分离** | ❌ 不支持 | ✅ 支持 |

---

## 🎯 使用场景推荐

### 强烈推荐嵌入式模式 ⭐⭐⭐⭐⭐

1. **边缘计算设备**
   - IoT 设备、智能硬件
   - 离线运行、低资源占用
   - 示例: 智能音箱、工业设备

2. **桌面应用**
   - 本地 AI 助手、文档管理
   - 用户数据本地化、隐私保护
   - 示例: Obsidian 插件、VS Code 扩展

3. **移动应用**
   - 离线 AI 功能
   - 低功耗、快速响应
   - 示例: 智能笔记、语音助手

4. **开发/测试环境**
   - 快速启动、零配置
   - 易于重置、隔离测试
   - 示例: CI/CD 测试、本地开发

### 推荐嵌入式模式 ⭐⭐⭐⭐☆

1. **小型 Web 应用**
   - 个人博客、小型企业网站
   - < 10万向量，< 10 QPS
   - 示例: 个人知识库、团队文档搜索

2. **企业内部工具**
   - 内部知识库、文档搜索
   - 用户数 < 100
   - 示例: 公司文档搜索、内部 FAQ

3. **原型验证**
   - MVP 开发、概念验证
   - 快速迭代、低成本
   - 示例: 创业项目、新功能验证

### 推荐 Server 模式 ⭐⭐⭐⭐⭐

1. **大规模 Web 应用**
   - > 100万向量
   - > 100 QPS
   - 示例: 电商搜索、内容推荐

2. **SaaS 应用**
   - 多租户隔离
   - 高可用要求
   - 示例: 企业级知识库、AI 平台

3. **关键业务系统**
   - 99.9%+ 可用性
   - 数据安全要求高
   - 示例: 金融系统、医疗系统

4. **分布式应用**
   - 多地域部署
   - 负载均衡
   - 示例: 全球化服务、CDN

---

## 🔄 迁移策略

### 从嵌入式迁移到 Server

**触发条件**:
- ✅ 向量数量 > 100万
- ✅ QPS > 100
- ✅ 需要高可用
- ✅ 需要分布式

**迁移步骤**:
1. **数据导出** (1-4 小时)
   ```rust
   // 遍历所有向量
   let all_vectors = export_all_vectors(&store).await?;
   ```

2. **Server 模式配置** (2-4 小时)
   ```rust
   let config = DeploymentMode::server_with_pgvector(
       "postgresql://localhost/agentmem",
       1536
   );
   ```

3. **数据导入** (1-24 小时)
   ```rust
   // 批量导入
   server_store.add_vectors(all_vectors).await?;
   ```

4. **验证** (1-2 小时)
   - 数据完整性检查
   - 性能测试
   - 功能测试

5. **切换** (< 1 小时)
   - 更新配置
   - 重启服务

**预计总时间**: 5-31 小时（取决于数据量）

### 从 Server 降级到嵌入式

**适用场景**:
- 成本优化
- 简化架构
- 数据量减少

**步骤**: 同上，反向操作

---

## 💡 最佳实践

### 嵌入式模式最佳实践

1. **数据路径管理**
   ```rust
   // ✅ 使用绝对路径或项目相对路径
   let store = LanceDBVectorStore::new("./data/vectors.lance", "vectors").await?;
   
   // ❌ 避免使用临时目录
   let store = LanceDBVectorStore::new("/tmp/vectors.lance", "vectors").await?;
   ```

2. **批量操作**
   ```rust
   // ✅ 批量插入
   store.add_vectors(vec![v1, v2, v3]).await?;
   
   // ❌ 逐个插入
   for v in vectors {
       store.add_vectors(vec![v]).await?; // 性能差
   }
   ```

3. **定期备份**
   ```bash
   # 每日备份
   cp -r ./data/vectors.lance ./backup/$(date +%Y%m%d)/
   ```

4. **监控磁盘空间**
   ```rust
   let stats = store.get_stats().await?;
   if stats.index_size > threshold {
       // 清理或扩容
   }
   ```

### Server 模式最佳实践

1. **连接池配置**
   ```rust
   let config = ServerModeConfig {
       pool_config: PoolConfig {
           min_connections: 5,
           max_connections: 20,
           connection_timeout: Duration::from_secs(30),
       },
       // ...
   };
   ```

2. **索引优化**
   ```sql
   -- 创建 HNSW 索引
   CREATE INDEX ON vectors USING hnsw (embedding vector_cosine_ops);
   ```

3. **读写分离**
   ```rust
   // 主库写入
   master_store.add_vectors(vectors).await?;
   
   // 从库读取
   let results = replica_store.search_vectors(query, 10, None).await?;
   ```

4. **监控和告警**
   ```rust
   // 定期健康检查
   let health = store.health_check().await?;
   if health.status != "healthy" {
       send_alert(&health);
   }
   ```

---

## 📈 性能优化建议

### 嵌入式模式优化

1. **使用 SSD 存储**
   - 提升 I/O 性能 3-10 倍

2. **增加内存**
   - 减少磁盘读取
   - 提升搜索性能

3. **批量操作**
   - 减少系统调用
   - 提升吞吐量

4. **合理设置 top_k**
   - 不要过大（推荐 < 100）
   - 减少计算量

### Server 模式优化

1. **索引选择**
   - HNSW: 高精度、高性能
   - IVFFlat: 大规模、低内存

2. **连接池调优**
   - 根据并发调整大小
   - 监控连接使用率

3. **缓存策略**
   - 热点数据缓存
   - 查询结果缓存

4. **分片策略**
   - 按租户分片
   - 按时间分片

---

## 🎯 总结

### 选择嵌入式模式，如果：
- ✅ 向量数 < 100万
- ✅ QPS < 100
- ✅ 单机部署
- ✅ 追求简单
- ✅ 成本敏感

### 选择 Server 模式，如果：
- ✅ 向量数 > 100万
- ✅ QPS > 100
- ✅ 需要高可用
- ✅ 需要分布式
- ✅ 关键业务

### 混合模式
- 开发/测试: 嵌入式
- 生产环境: Server
- 边缘节点: 嵌入式
- 中心服务: Server

---

## 📞 支持

- 技术文档: `doc/technical-design/memory-systems/mem21.md`
- 嵌入式指南: `EMBEDDED_MODE_GUIDE.md`
- 生产可行性分析: `PRODUCTION_READINESS_ANALYSIS.md`
- 示例代码: `examples/embedded-mode-demo/`

