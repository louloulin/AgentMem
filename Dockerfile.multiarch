# Multi-architecture Docker build for AgentMem
# Supports: linux/amd64, linux/arm64, linux/arm/v7
# Optimized for China domestic network with Aliyun mirrors
# æ”¯æŒå¤šæž¶æž„æž„å»º

# Build stage - using latest Rust for Cargo.lock v4 support
FROM --platform=$BUILDPLATFORM rust:latest AS builder

# Build arguments for cross-compilation
ARG BUILDPLATFORM
ARG TARGETPLATFORM
ARG TARGETARCH

# Build optimization arguments
# CARGO_BUILD_JOBS: Limit parallel compilation jobs to reduce memory usage
# Default to 2 for memory-constrained environments, can be overridden
ARG CARGO_BUILD_JOBS=2

# Configure Aliyun APT mirror for faster package downloads in China
RUN sed -i 's/deb.debian.org/mirrors.aliyun.com/g' /etc/apt/sources.list.d/debian.sources 2>/dev/null || true && \
    sed -i 's/security.debian.org/mirrors.aliyun.com\/debian-security/g' /etc/apt/sources.list.d/debian.sources 2>/dev/null || true

# Install build dependencies including protobuf-compiler
# Also install cross-compilation toolchains based on target architecture
RUN apt-get update && apt-get install -y \
    pkg-config \
    libssl-dev \
    libpq-dev \
    ca-certificates \
    protobuf-compiler \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# Create app user
RUN useradd -m -u 1001 agentmem

# Set working directory
WORKDIR /app

# Copy all source code
COPY . .

# Prepare ONNX Runtime library for ort-sys build script
# ort-sys will try to download ONNX Runtime from cdn.pyke.io, which may fail
# We provide local library to avoid network issues during build
RUN case "$TARGETARCH" in \
    amd64) \
        if [ -d "/app/lib/linux-amd64" ]; then \
            mkdir -p /app/onnxruntime && \
            cp -r /app/lib/linux-amd64/* /app/onnxruntime/ 2>/dev/null || true && \
            echo "âœ… ONNX Runtime library prepared for amd64" && \
            ls -la /app/onnxruntime/ || true; \
        else \
            echo "âš ï¸  Warning: lib/linux-amd64 not found, ort-sys will try to download"; \
        fi \
        ;; \
    arm64) \
        if [ -d "/app/lib/linux-arm64" ]; then \
            mkdir -p /app/onnxruntime && \
            cp -r /app/lib/linux-arm64/* /app/onnxruntime/ 2>/dev/null || true && \
            echo "âœ… ONNX Runtime library prepared for arm64"; \
        else \
            echo "âš ï¸  Warning: lib/linux-arm64 not found, ort-sys will try to download"; \
        fi \
        ;; \
    arm) \
        if [ -d "/app/lib/linux-arm" ]; then \
            mkdir -p /app/onnxruntime && \
            cp -r /app/lib/linux-arm/* /app/onnxruntime/ 2>/dev/null || true && \
            echo "âœ… ONNX Runtime library prepared for arm"; \
        else \
            echo "âš ï¸  Warning: lib/linux-arm not found, ort-sys will try to download"; \
        fi \
        ;; \
    esac

# Configure Cargo (optional mirror support via build arg)
# Use official crates.io by default, or set CARGO_MIRROR build arg to use a mirror
# Example: docker build --build-arg CARGO_MIRROR=https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git
ARG CARGO_MIRROR=""
RUN mkdir -p /app/.cargo && \
    if [ -n "$CARGO_MIRROR" ]; then \
        echo "[source.crates-io]" > /app/.cargo/config.toml && \
        echo "replace-with = 'mirror'" >> /app/.cargo/config.toml && \
        echo "" >> /app/.cargo/config.toml && \
        echo "[source.mirror]" >> /app/.cargo/config.toml && \
        echo "registry = \"$CARGO_MIRROR\"" >> /app/.cargo/config.toml && \
        echo "" >> /app/.cargo/config.toml; \
    fi && \
    echo "[net]" >> /app/.cargo/config.toml && \
    echo "git-fetch-with-cli = true" >> /app/.cargo/config.toml

# Set CARGO_HOME to use our config
ENV CARGO_HOME=/app/.cargo

# Determine target triple based on TARGETARCH
RUN case "$TARGETARCH" in \
    amd64) echo "x86_64-unknown-linux-gnu" > /tmp/target_triple ;; \
    arm64) echo "aarch64-unknown-linux-gnu" > /tmp/target_triple ;; \
    arm) echo "armv7-unknown-linux-gnueabihf" > /tmp/target_triple ;; \
    *) echo "x86_64-unknown-linux-gnu" > /tmp/target_triple ;; \
    esac

# Install cross-compilation target and toolchain
# Always install the target triple, even for native builds (rustup target add is idempotent)
# This is necessary when BUILDPLATFORM differs from TARGETPLATFORM (e.g., building amd64 on arm64)
RUN TARGET_TRIPLE=$(cat /tmp/target_triple) && \
    rustup target add $TARGET_TRIPLE && \
    case "$TARGETARCH" in \
        amd64) \
            dpkg --add-architecture amd64 2>/dev/null || true && \
            apt-get update && apt-get install -y \
                gcc-x86-64-linux-gnu \
                g++-x86-64-linux-gnu \
                libssl-dev:amd64 \
                && rm -rf /var/lib/apt/lists/* \
            ;; \
        arm64) \
            dpkg --add-architecture arm64 2>/dev/null || true && \
            apt-get update && apt-get install -y \
                gcc-aarch64-linux-gnu \
                g++-aarch64-linux-gnu \
                && rm -rf /var/lib/apt/lists/* \
            ;; \
        arm) \
            dpkg --add-architecture armhf 2>/dev/null || true && \
            apt-get update && apt-get install -y \
                gcc-arm-linux-gnueabihf \
                g++-arm-linux-gnueabihf \
                && rm -rf /var/lib/apt/lists/* \
            ;; \
        *) \
            echo "Unknown target architecture: $TARGETARCH" && exit 1 \
            ;; \
    esac

# Configure Cargo linker and rustflags for cross-compilation
# CRITICAL: This must be done BEFORE any build scripts run
# Build scripts detect CPU features at compile time, so we must disable them early
RUN TARGET_TRIPLE=$(cat /tmp/target_triple) && \
    case "$TARGETARCH" in \
        amd64) \
            printf '[target.x86_64-unknown-linux-gnu]\nlinker = "x86_64-linux-gnu-gcc"\nrustflags = [\n    "-C", "link-arg=-Wl,--allow-multiple-definition",\n    "-C", "target-cpu=generic",\n    "-C", "target-feature=-avx512f,-avx512cd,-avx512bw,-avx512dq,-avx512vl,-avx2,-sse4.2"\n]\n' >> /app/.cargo/config.toml \
            ;; \
        arm64) \
            printf '[target.aarch64-unknown-linux-gnu]\nlinker = "aarch64-linux-gnu-gcc"\nrustflags = [\n    "-C", "link-arg=-Wl,--allow-multiple-definition",\n    "-C", "target-cpu=generic"\n]\n' >> /app/.cargo/config.toml \
            ;; \
        arm) \
            printf '[target.armv7-unknown-linux-gnueabihf]\nlinker = "arm-linux-gnueabihf-gcc"\nrustflags = [\n    "-C", "link-arg=-Wl,--allow-multiple-definition",\n    "-C", "target-cpu=generic"\n]\n' >> /app/.cargo/config.toml \
            ;; \
    esac

# Build the application with cross-compilation environment variables
# CRITICAL: Set environment variables BEFORE any cargo commands run
# Build scripts check these variables at runtime to detect CPU features
RUN TARGET_TRIPLE=$(cat /tmp/target_triple) && \
    # Set architecture-specific environment variables
    case "$TARGETARCH" in \
        amd64) \
            export CC_x86_64_unknown_linux_gnu=x86_64-linux-gnu-gcc && \
            export CXX_x86_64_unknown_linux_gnu=x86_64-linux-gnu-g++ && \
            export AR_x86_64_unknown_linux_gnu=x86_64-linux-gnu-ar && \
            export PKG_CONFIG_ALLOW_CROSS=1 && \
            export PKG_CONFIG_PATH=/usr/lib/x86_64-linux-gnu/pkgconfig && \
            # CRITICAL: Disable ALL SIMD features including AVX2 and SSE4.2
            # This prevents build scripts from detecting and using any SIMD optimizations
            export RUSTFLAGS="-C link-arg=-Wl,--allow-multiple-definition -C target-cpu=generic -C target-feature=-avx512f,-avx512cd,-avx512bw,-avx512dq,-avx512vl,-avx2,-sse4.2" \
            ;; \
        arm64) \
            export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc && \
            export CXX_aarch64_unknown_linux_gnu=aarch64-linux-gnu-g++ && \
            export AR_aarch64_unknown_linux_gnu=aarch64-linux-gnu-ar && \
            export PKG_CONFIG_ALLOW_CROSS=1 && \
            export RUSTFLAGS="-C link-arg=-Wl,--allow-multiple-definition -C target-cpu=generic" \
            ;; \
        arm) \
            export CC_armv7_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc && \
            export CXX_armv7_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++ && \
            export AR_armv7_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar && \
            export PKG_CONFIG_ALLOW_CROSS=1 && \
            export RUSTFLAGS="-C link-arg=-Wl,--allow-multiple-definition -C target-cpu=generic" \
            ;; \
    esac && \
    # CRITICAL: Override build script CPU feature detection
    # Build scripts use cfg!(target_feature = "...") which checks CARGO_CFG_TARGET_FEATURE
    # Setting these to empty or generic prevents build scripts from detecting SIMD
    export CARGO_CFG_TARGET_CPU="generic" && \
    export CARGO_CFG_TARGET_FEATURE="" && \
    # Explicitly disable all AVX-512 features for build scripts
    # These are checked by build scripts using cfg!() macro
    export CARGO_CFG_TARGET_FEATURE_AVX512F="" && \
    export CARGO_CFG_TARGET_FEATURE_AVX512CD="" && \
    export CARGO_CFG_TARGET_FEATURE_AVX512BW="" && \
    export CARGO_CFG_TARGET_FEATURE_AVX512DQ="" && \
    export CARGO_CFG_TARGET_FEATURE_AVX512VL="" && \
    # Disable AVX2 and SSE4.2 as well to be safe
    export CARGO_CFG_TARGET_FEATURE_AVX2="" && \
    export CARGO_CFG_TARGET_FEATURE_SSE4_2="" && \
    # Configure ort-sys to use local ONNX Runtime library
    if [ -d "/app/onnxruntime" ] && ([ -f "/app/onnxruntime/libonnxruntime.so" ] || [ -f "/app/onnxruntime/lib/libonnxruntime.so" ]); then \
        if [ -f "/app/onnxruntime/lib/libonnxruntime.so" ]; then \
            export ORT_LIB_LOCATION="/app/onnxruntime/lib" && \
            echo "âœ… Using ONNX Runtime from /app/onnxruntime/lib"; \
        else \
            export ORT_LIB_LOCATION="/app/onnxruntime" && \
            echo "âœ… Using ONNX Runtime from /app/onnxruntime"; \
        fi && \
        export ORT_PREFER_DYNAMIC_LINK="1"; \
    else \
        echo "âš ï¸  Warning: Local ONNX Runtime not found, ort-sys will try to download"; \
    fi && \
    # Verify configuration
    echo "=== Build Configuration ===" && \
    echo "TARGET_TRIPLE=${TARGET_TRIPLE}" && \
    echo "TARGETARCH=${TARGETARCH}" && \
    echo "RUSTFLAGS=${RUSTFLAGS}" && \
    echo "CARGO_BUILD_JOBS=${CARGO_BUILD_JOBS}" && \
    echo "CARGO_CFG_TARGET_CPU=${CARGO_CFG_TARGET_CPU}" && \
    echo "CARGO_CFG_TARGET_FEATURE=${CARGO_CFG_TARGET_FEATURE}" && \
    echo "ORT_LIB_LOCATION=${ORT_LIB_LOCATION:-not set}" && \
    echo "=== Cargo Config ===" && \
    cat /app/.cargo/config.toml && \
    echo "=== Starting Build ===" && \
    # CRITICAL: Clean ALL build artifacts to remove any AVX-512 compiled code
    # This is essential for cross-compilation to ensure old cached artifacts don't interfere
    echo "ðŸ§¹ Cleaning build cache..." && \
    cargo clean || true && \
    rm -rf /app/target/* || true && \
    rm -rf /root/.cargo/registry/cache/* || true && \
    rm -rf /root/.cargo/git/checkouts/* || true && \
    rm -rf /root/.cargo/registry/src/* || true && \
    echo "âœ… Build cache cleaned" && \
    # Build with the configured settings
    # CRITICAL: Explicitly pass RUSTFLAGS to ensure they're applied to build scripts
    export CARGO_BUILD_JOBS=$CARGO_BUILD_JOBS && \
    RUSTFLAGS="${RUSTFLAGS}" cargo build --release --workspace \
    --bin agent-mem-server \
    --target $TARGET_TRIPLE \
    --jobs $CARGO_BUILD_JOBS \
    --exclude agent-mem-python \
    --exclude demo-multimodal \
    --exclude demo-codebase-memory

# Determine the binary path based on target architecture
RUN TARGET_TRIPLE=$(cat /tmp/target_triple) && \
    cp /app/target/$TARGET_TRIPLE/release/agent-mem-server /tmp/agent-mem-server

# Runtime stage
# Use debian:sid-slim (unstable alias) for GLIBC 2.38+ compatibility
FROM debian:sid-slim AS runtime

# Install runtime dependencies
RUN apt-get update && apt-get install -y \
    ca-certificates \
    libssl3 \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

# Create app user
RUN useradd -m -u 1001 agentmem

# Set working directory
WORKDIR /app

# Copy binary from builder
COPY --from=builder /tmp/agent-mem-server /app/agent-mem-server

# Copy ONNX Runtime library if available
# Copy lib directory first, then conditionally copy libraries to /usr/lib
COPY --from=builder /app/lib/ /app/lib/
RUN mkdir -p /usr/lib && \
    if [ -d /app/lib/linux-amd64 ]; then cp /app/lib/linux-amd64/libonnxruntime.so* /usr/lib/ 2>/dev/null || true; fi && \
    if [ -d /app/lib/linux-arm64 ]; then cp /app/lib/linux-arm64/libonnxruntime.so* /usr/lib/ 2>/dev/null || true; fi && \
    if [ -d /app/lib/linux-arm ]; then cp /app/lib/linux-arm/libonnxruntime.so* /usr/lib/ 2>/dev/null || true; fi

# Set ownership
RUN chown -R agentmem:agentmem /app

# Switch to app user
USER agentmem

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Run the server
CMD ["./agent-mem-server"]
